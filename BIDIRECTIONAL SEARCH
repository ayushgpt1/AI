from collections import deque

def bidirectional_search(graph, start, goal):
    if start == goal:
        return [start]

    # Sets to store visited nodes
    visited_start, visited_goal = {start}, {goal}

    # Queues for BFS from both sides
    queue_start, queue_goal = deque([start]), deque([goal])

    while queue_start and queue_goal:
        # Search from start side
        if bfs_step(graph, queue_start, visited_start, visited_goal):
            return construct_path(start, goal, visited_start & visited_goal)

        # Search from goal side
        if bfs_step(graph, queue_goal, visited_goal, visited_start):
            return construct_path(start, goal, visited_start & visited_goal)

    return None

def bfs_step(graph, queue, visited_from, visited_other):
    node = queue.popleft()
    for neighbor in graph.get(node, []):
        if neighbor not in visited_from:
            visited_from.add(neighbor)
            queue.append(neighbor)
        if neighbor in visited_other:
            return True
    return False

def construct_path(start, goal, meet_point):
    meeting_node = list(meet_point)[0]  # Get the meeting point
    return f"Path from {start} to {goal}: {start} -> {meeting_node} -> {goal}"

# Example usage
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

start, goal = 'A', 'F'
path = bidirectional_search(graph, start, goal)
print(path if path else "No path")
